# 数据持久化 - AOF

Redis 是一个数据存放在内存中，所以一旦服务器宕机，数据将会丢失。所以 Redis 需要需要实现数据的持久化，有两大机制，即 AOF 日志和 RDB 快照。

### AOF 日志

AOF 是写后日志，即 Redis 先执行命令，操作完数据后记录日志。

AOF 日志保存的是 Redis 执行的命令：
```
set test abcde
--- 对应的 AOF 日志---
*3
$3
set
$4
test
$5
abcde
```

所以先执行命令后记录日志的好处：
* 避免了错误命令的记录
* 且不会堵塞命令的执行操作。

对应的缺陷：
* 执行完命令后宕机日志没法记录，导致部分数据可能丢失
* AOF日志在主线程中执行，所以也会有可能阻塞下一个命令的执行。

针对这写缺陷，Redis 提供了 3 种写回策略：
1. 同步写回：每个写命令执行完，立马同步将日志写回磁盘
2. 每秒写回：每个写命令执行完，先把日志写到 AOF 文件的内存缓冲区，后每秒写回磁盘
3. 操作系统控制写回：每个写命令执行完，先把日志写到 AOF 文件的内存缓冲区，后操作系统控制写回磁盘

3种策略无法同时解决所有的缺陷，只能根据需求择优选择

![](https://sidfate.oss-cn-hangzhou.aliyuncs.com/uPic/qg4vEh.jpg)

为了控制磁盘日志文件过大导致的性能问题，Redis 对写入的命令日志做了优化：AOF 重写机制。这个机制的本质就是在重写的时候，是根据这个键值对当前的最新状态，为它生成对应的写入命令，这样这个键值对的多个变更命令就可以写入一条日志。并且重写的过程是由后台进程 bgrewriteaof 完成的，不阻塞主线程。

重写的过程：每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。

主线程有新的写入怎么保证跟重写的 aof 日志一致？
1. 主线程通过 fork 出的子进程 bgrewriteaof
2. 子进程重写时写入新的重写日志文件，重写失败时不会文件直接删除，不影响主线的 AOF 日志记录
3. 对于所有新执行的写入命令，主线程一边将它们累积到一个内存缓存中，一边将这些改动追加到现有 AOF 文件的末尾，这样样即使子线程重写的中途发生停机，现有的 AOF 文件也还是安全的
4. 当子进程完成重写工作时，它给父进程发送一个信号，父进程在接收到信号之后，将内存缓存中的所有数据追加到新 AOF 文件的末尾。
